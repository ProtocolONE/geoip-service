// Code generated by protoc-gen-go. DO NOT EDIT.
// source: geoip.proto

package proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GeoIpDataRequest struct {
	IP                   string   `protobuf:"bytes,1,opt,name=IP,proto3" json:"IP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeoIpDataRequest) Reset()         { *m = GeoIpDataRequest{} }
func (m *GeoIpDataRequest) String() string { return proto.CompactTextString(m) }
func (*GeoIpDataRequest) ProtoMessage()    {}
func (*GeoIpDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{0}
}
func (m *GeoIpDataRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpDataRequest.Unmarshal(m, b)
}
func (m *GeoIpDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpDataRequest.Marshal(b, m, deterministic)
}
func (dst *GeoIpDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpDataRequest.Merge(dst, src)
}
func (m *GeoIpDataRequest) XXX_Size() int {
	return xxx_messageInfo_GeoIpDataRequest.Size(m)
}
func (m *GeoIpDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpDataRequest proto.InternalMessageInfo

func (m *GeoIpDataRequest) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

type GeoIpDataResponse struct {
	City                 *GeoIpCity               `protobuf:"bytes,1,opt,name=City,proto3" json:"City,omitempty"`
	Continent            *GeoIpContinent          `protobuf:"bytes,2,opt,name=Continent,proto3" json:"Continent,omitempty"`
	Country              *GeoIpCountry            `protobuf:"bytes,3,opt,name=Country,proto3" json:"Country,omitempty"`
	Location             *GeoIpLocation           `protobuf:"bytes,4,opt,name=Location,proto3" json:"Location,omitempty"`
	Postal               *GeoIpPostal             `protobuf:"bytes,5,opt,name=Postal,proto3" json:"Postal,omitempty"`
	RepresentedCountry   *GeoIpRepresentedCountry `protobuf:"bytes,6,opt,name=RepresentedCountry,proto3" json:"RepresentedCountry,omitempty"`
	Subdivisions         []*GeoIpSubdivision      `protobuf:"bytes,7,rep,name=Subdivisions,proto3" json:"Subdivisions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GeoIpDataResponse) Reset()         { *m = GeoIpDataResponse{} }
func (m *GeoIpDataResponse) String() string { return proto.CompactTextString(m) }
func (*GeoIpDataResponse) ProtoMessage()    {}
func (*GeoIpDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{1}
}
func (m *GeoIpDataResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpDataResponse.Unmarshal(m, b)
}
func (m *GeoIpDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpDataResponse.Marshal(b, m, deterministic)
}
func (dst *GeoIpDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpDataResponse.Merge(dst, src)
}
func (m *GeoIpDataResponse) XXX_Size() int {
	return xxx_messageInfo_GeoIpDataResponse.Size(m)
}
func (m *GeoIpDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpDataResponse proto.InternalMessageInfo

func (m *GeoIpDataResponse) GetCity() *GeoIpCity {
	if m != nil {
		return m.City
	}
	return nil
}

func (m *GeoIpDataResponse) GetContinent() *GeoIpContinent {
	if m != nil {
		return m.Continent
	}
	return nil
}

func (m *GeoIpDataResponse) GetCountry() *GeoIpCountry {
	if m != nil {
		return m.Country
	}
	return nil
}

func (m *GeoIpDataResponse) GetLocation() *GeoIpLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GeoIpDataResponse) GetPostal() *GeoIpPostal {
	if m != nil {
		return m.Postal
	}
	return nil
}

func (m *GeoIpDataResponse) GetRepresentedCountry() *GeoIpRepresentedCountry {
	if m != nil {
		return m.RepresentedCountry
	}
	return nil
}

func (m *GeoIpDataResponse) GetSubdivisions() []*GeoIpSubdivision {
	if m != nil {
		return m.Subdivisions
	}
	return nil
}

type GeoIpCity struct {
	GeoNameID            uint32            `protobuf:"varint,1,opt,name=GeoNameID,proto3" json:"GeoNameID,omitempty"`
	Names                map[string]string `protobuf:"bytes,2,rep,name=Names,proto3" json:"Names,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GeoIpCity) Reset()         { *m = GeoIpCity{} }
func (m *GeoIpCity) String() string { return proto.CompactTextString(m) }
func (*GeoIpCity) ProtoMessage()    {}
func (*GeoIpCity) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{2}
}
func (m *GeoIpCity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpCity.Unmarshal(m, b)
}
func (m *GeoIpCity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpCity.Marshal(b, m, deterministic)
}
func (dst *GeoIpCity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpCity.Merge(dst, src)
}
func (m *GeoIpCity) XXX_Size() int {
	return xxx_messageInfo_GeoIpCity.Size(m)
}
func (m *GeoIpCity) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpCity.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpCity proto.InternalMessageInfo

func (m *GeoIpCity) GetGeoNameID() uint32 {
	if m != nil {
		return m.GeoNameID
	}
	return 0
}

func (m *GeoIpCity) GetNames() map[string]string {
	if m != nil {
		return m.Names
	}
	return nil
}

type GeoIpContinent struct {
	Code                 string            `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
	GeoNameID            uint32            `protobuf:"varint,2,opt,name=GeoNameID,proto3" json:"GeoNameID,omitempty"`
	Names                map[string]string `protobuf:"bytes,3,rep,name=Names,proto3" json:"Names,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GeoIpContinent) Reset()         { *m = GeoIpContinent{} }
func (m *GeoIpContinent) String() string { return proto.CompactTextString(m) }
func (*GeoIpContinent) ProtoMessage()    {}
func (*GeoIpContinent) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{3}
}
func (m *GeoIpContinent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpContinent.Unmarshal(m, b)
}
func (m *GeoIpContinent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpContinent.Marshal(b, m, deterministic)
}
func (dst *GeoIpContinent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpContinent.Merge(dst, src)
}
func (m *GeoIpContinent) XXX_Size() int {
	return xxx_messageInfo_GeoIpContinent.Size(m)
}
func (m *GeoIpContinent) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpContinent.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpContinent proto.InternalMessageInfo

func (m *GeoIpContinent) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *GeoIpContinent) GetGeoNameID() uint32 {
	if m != nil {
		return m.GeoNameID
	}
	return 0
}

func (m *GeoIpContinent) GetNames() map[string]string {
	if m != nil {
		return m.Names
	}
	return nil
}

type GeoIpCountry struct {
	GeoNameID            uint32            `protobuf:"varint,1,opt,name=GeoNameID,proto3" json:"GeoNameID,omitempty"`
	IsInEuropeanUnion    bool              `protobuf:"varint,2,opt,name=IsInEuropeanUnion,proto3" json:"IsInEuropeanUnion,omitempty"`
	IsoCode              string            `protobuf:"bytes,3,opt,name=IsoCode,proto3" json:"IsoCode,omitempty"`
	Names                map[string]string `protobuf:"bytes,4,rep,name=Names,proto3" json:"Names,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GeoIpCountry) Reset()         { *m = GeoIpCountry{} }
func (m *GeoIpCountry) String() string { return proto.CompactTextString(m) }
func (*GeoIpCountry) ProtoMessage()    {}
func (*GeoIpCountry) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{4}
}
func (m *GeoIpCountry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpCountry.Unmarshal(m, b)
}
func (m *GeoIpCountry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpCountry.Marshal(b, m, deterministic)
}
func (dst *GeoIpCountry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpCountry.Merge(dst, src)
}
func (m *GeoIpCountry) XXX_Size() int {
	return xxx_messageInfo_GeoIpCountry.Size(m)
}
func (m *GeoIpCountry) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpCountry.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpCountry proto.InternalMessageInfo

func (m *GeoIpCountry) GetGeoNameID() uint32 {
	if m != nil {
		return m.GeoNameID
	}
	return 0
}

func (m *GeoIpCountry) GetIsInEuropeanUnion() bool {
	if m != nil {
		return m.IsInEuropeanUnion
	}
	return false
}

func (m *GeoIpCountry) GetIsoCode() string {
	if m != nil {
		return m.IsoCode
	}
	return ""
}

func (m *GeoIpCountry) GetNames() map[string]string {
	if m != nil {
		return m.Names
	}
	return nil
}

type GeoIpLocation struct {
	AccuracyRadius       uint32   `protobuf:"varint,1,opt,name=AccuracyRadius,proto3" json:"AccuracyRadius,omitempty"`
	Latitude             float64  `protobuf:"fixed64,2,opt,name=Latitude,proto3" json:"Latitude,omitempty"`
	Longitude            float64  `protobuf:"fixed64,3,opt,name=Longitude,proto3" json:"Longitude,omitempty"`
	MetroCode            uint32   `protobuf:"varint,4,opt,name=MetroCode,proto3" json:"MetroCode,omitempty"`
	TimeZone             string   `protobuf:"bytes,5,opt,name=TimeZone,proto3" json:"TimeZone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeoIpLocation) Reset()         { *m = GeoIpLocation{} }
func (m *GeoIpLocation) String() string { return proto.CompactTextString(m) }
func (*GeoIpLocation) ProtoMessage()    {}
func (*GeoIpLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{5}
}
func (m *GeoIpLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpLocation.Unmarshal(m, b)
}
func (m *GeoIpLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpLocation.Marshal(b, m, deterministic)
}
func (dst *GeoIpLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpLocation.Merge(dst, src)
}
func (m *GeoIpLocation) XXX_Size() int {
	return xxx_messageInfo_GeoIpLocation.Size(m)
}
func (m *GeoIpLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpLocation.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpLocation proto.InternalMessageInfo

func (m *GeoIpLocation) GetAccuracyRadius() uint32 {
	if m != nil {
		return m.AccuracyRadius
	}
	return 0
}

func (m *GeoIpLocation) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *GeoIpLocation) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *GeoIpLocation) GetMetroCode() uint32 {
	if m != nil {
		return m.MetroCode
	}
	return 0
}

func (m *GeoIpLocation) GetTimeZone() string {
	if m != nil {
		return m.TimeZone
	}
	return ""
}

type GeoIpPostal struct {
	Code                 string   `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeoIpPostal) Reset()         { *m = GeoIpPostal{} }
func (m *GeoIpPostal) String() string { return proto.CompactTextString(m) }
func (*GeoIpPostal) ProtoMessage()    {}
func (*GeoIpPostal) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{6}
}
func (m *GeoIpPostal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpPostal.Unmarshal(m, b)
}
func (m *GeoIpPostal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpPostal.Marshal(b, m, deterministic)
}
func (dst *GeoIpPostal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpPostal.Merge(dst, src)
}
func (m *GeoIpPostal) XXX_Size() int {
	return xxx_messageInfo_GeoIpPostal.Size(m)
}
func (m *GeoIpPostal) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpPostal.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpPostal proto.InternalMessageInfo

func (m *GeoIpPostal) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type GeoIpRepresentedCountry struct {
	GeoNameID            uint32            `protobuf:"varint,1,opt,name=GeoNameID,proto3" json:"GeoNameID,omitempty"`
	IsInEuropeanUnion    bool              `protobuf:"varint,2,opt,name=IsInEuropeanUnion,proto3" json:"IsInEuropeanUnion,omitempty"`
	IsoCode              string            `protobuf:"bytes,3,opt,name=IsoCode,proto3" json:"IsoCode,omitempty"`
	Type                 string            `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Names                map[string]string `protobuf:"bytes,5,rep,name=Names,proto3" json:"Names,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GeoIpRepresentedCountry) Reset()         { *m = GeoIpRepresentedCountry{} }
func (m *GeoIpRepresentedCountry) String() string { return proto.CompactTextString(m) }
func (*GeoIpRepresentedCountry) ProtoMessage()    {}
func (*GeoIpRepresentedCountry) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{7}
}
func (m *GeoIpRepresentedCountry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpRepresentedCountry.Unmarshal(m, b)
}
func (m *GeoIpRepresentedCountry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpRepresentedCountry.Marshal(b, m, deterministic)
}
func (dst *GeoIpRepresentedCountry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpRepresentedCountry.Merge(dst, src)
}
func (m *GeoIpRepresentedCountry) XXX_Size() int {
	return xxx_messageInfo_GeoIpRepresentedCountry.Size(m)
}
func (m *GeoIpRepresentedCountry) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpRepresentedCountry.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpRepresentedCountry proto.InternalMessageInfo

func (m *GeoIpRepresentedCountry) GetGeoNameID() uint32 {
	if m != nil {
		return m.GeoNameID
	}
	return 0
}

func (m *GeoIpRepresentedCountry) GetIsInEuropeanUnion() bool {
	if m != nil {
		return m.IsInEuropeanUnion
	}
	return false
}

func (m *GeoIpRepresentedCountry) GetIsoCode() string {
	if m != nil {
		return m.IsoCode
	}
	return ""
}

func (m *GeoIpRepresentedCountry) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *GeoIpRepresentedCountry) GetNames() map[string]string {
	if m != nil {
		return m.Names
	}
	return nil
}

type GeoIpSubdivision struct {
	GeoNameID            uint32            `protobuf:"varint,1,opt,name=GeoNameID,proto3" json:"GeoNameID,omitempty"`
	IsoCode              string            `protobuf:"bytes,2,opt,name=IsoCode,proto3" json:"IsoCode,omitempty"`
	Names                map[string]string `protobuf:"bytes,3,rep,name=Names,proto3" json:"Names,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GeoIpSubdivision) Reset()         { *m = GeoIpSubdivision{} }
func (m *GeoIpSubdivision) String() string { return proto.CompactTextString(m) }
func (*GeoIpSubdivision) ProtoMessage()    {}
func (*GeoIpSubdivision) Descriptor() ([]byte, []int) {
	return fileDescriptor_geoip_c8ff90349966575d, []int{8}
}
func (m *GeoIpSubdivision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeoIpSubdivision.Unmarshal(m, b)
}
func (m *GeoIpSubdivision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeoIpSubdivision.Marshal(b, m, deterministic)
}
func (dst *GeoIpSubdivision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoIpSubdivision.Merge(dst, src)
}
func (m *GeoIpSubdivision) XXX_Size() int {
	return xxx_messageInfo_GeoIpSubdivision.Size(m)
}
func (m *GeoIpSubdivision) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoIpSubdivision.DiscardUnknown(m)
}

var xxx_messageInfo_GeoIpSubdivision proto.InternalMessageInfo

func (m *GeoIpSubdivision) GetGeoNameID() uint32 {
	if m != nil {
		return m.GeoNameID
	}
	return 0
}

func (m *GeoIpSubdivision) GetIsoCode() string {
	if m != nil {
		return m.IsoCode
	}
	return ""
}

func (m *GeoIpSubdivision) GetNames() map[string]string {
	if m != nil {
		return m.Names
	}
	return nil
}

func init() {
	proto.RegisterType((*GeoIpDataRequest)(nil), "proto.GeoIpDataRequest")
	proto.RegisterType((*GeoIpDataResponse)(nil), "proto.GeoIpDataResponse")
	proto.RegisterType((*GeoIpCity)(nil), "proto.GeoIpCity")
	proto.RegisterMapType((map[string]string)(nil), "proto.GeoIpCity.NamesEntry")
	proto.RegisterType((*GeoIpContinent)(nil), "proto.GeoIpContinent")
	proto.RegisterMapType((map[string]string)(nil), "proto.GeoIpContinent.NamesEntry")
	proto.RegisterType((*GeoIpCountry)(nil), "proto.GeoIpCountry")
	proto.RegisterMapType((map[string]string)(nil), "proto.GeoIpCountry.NamesEntry")
	proto.RegisterType((*GeoIpLocation)(nil), "proto.GeoIpLocation")
	proto.RegisterType((*GeoIpPostal)(nil), "proto.GeoIpPostal")
	proto.RegisterType((*GeoIpRepresentedCountry)(nil), "proto.GeoIpRepresentedCountry")
	proto.RegisterMapType((map[string]string)(nil), "proto.GeoIpRepresentedCountry.NamesEntry")
	proto.RegisterType((*GeoIpSubdivision)(nil), "proto.GeoIpSubdivision")
	proto.RegisterMapType((map[string]string)(nil), "proto.GeoIpSubdivision.NamesEntry")
}

func init() { proto.RegisterFile("geoip.proto", fileDescriptor_geoip_c8ff90349966575d) }

var fileDescriptor_geoip_c8ff90349966575d = []byte{
	// 605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x3f, 0x69, 0xeb, 0x49, 0x1b, 0xa5, 0x43, 0x51, 0xad, 0x80, 0xaa, 0x60, 0x21, 0x54,
	0x10, 0x44, 0x90, 0x22, 0x14, 0xc1, 0x01, 0x50, 0x5a, 0x21, 0x4b, 0xa1, 0x8a, 0xb6, 0x70, 0xe1,
	0xe6, 0x26, 0xab, 0xca, 0xa2, 0xdd, 0x35, 0xf6, 0x3a, 0x52, 0xde, 0x80, 0x13, 0x47, 0x5e, 0x82,
	0x2b, 0x67, 0x9e, 0x86, 0x07, 0x41, 0x1e, 0xdb, 0xc9, 0x3a, 0x49, 0xe9, 0x25, 0xe2, 0xe4, 0xdd,
	0xf9, 0xbe, 0x19, 0xcf, 0xff, 0x42, 0xfd, 0x82, 0xcb, 0x30, 0xea, 0x44, 0xb1, 0x54, 0x12, 0x6b,
	0xf4, 0xf1, 0x3c, 0x68, 0xbe, 0xe7, 0xd2, 0x8f, 0x8e, 0x03, 0x15, 0x30, 0xfe, 0x35, 0xe5, 0x89,
	0xc2, 0x06, 0x98, 0xfe, 0xd0, 0x35, 0xda, 0xc6, 0xa1, 0xc3, 0x4c, 0x7f, 0xe8, 0x7d, 0xb3, 0x60,
	0x57, 0x23, 0x25, 0x91, 0x14, 0x09, 0xc7, 0x07, 0x60, 0xf7, 0x43, 0x35, 0x25, 0x5e, 0xbd, 0xdb,
	0xcc, 0xcd, 0x76, 0x88, 0x97, 0xc9, 0x19, 0xa1, 0x78, 0x04, 0x4e, 0x5f, 0x0a, 0x15, 0x0a, 0x2e,
	0x94, 0x6b, 0x12, 0xf5, 0x4e, 0x85, 0x5a, 0x82, 0x6c, 0xce, 0xc3, 0xa7, 0xb0, 0xd9, 0x97, 0xa9,
	0x50, 0xf1, 0xd4, 0xb5, 0x48, 0xe5, 0x76, 0x55, 0x85, 0x20, 0x56, 0x72, 0xf0, 0x19, 0x6c, 0x0d,
	0xe4, 0x28, 0x50, 0xa1, 0x14, 0xae, 0x4d, 0xfc, 0x3d, 0x9d, 0x5f, 0x62, 0x6c, 0xc6, 0xc2, 0xc7,
	0xb0, 0x31, 0x94, 0x89, 0x0a, 0x2e, 0xdd, 0x1a, 0xf1, 0x51, 0xe7, 0xe7, 0x08, 0x2b, 0x18, 0x78,
	0x0a, 0xc8, 0x78, 0x14, 0xf3, 0x84, 0x0b, 0xc5, 0xc7, 0xa5, 0x5f, 0x1b, 0xa4, 0x77, 0xa0, 0xeb,
	0x2d, 0xb3, 0xd8, 0x0a, 0x4d, 0x7c, 0x0d, 0xdb, 0x67, 0xe9, 0xf9, 0x38, 0x9c, 0x84, 0x49, 0x28,
	0x45, 0xe2, 0x6e, 0xb6, 0xad, 0xc3, 0x7a, 0x77, 0x5f, 0xb7, 0xa4, 0xe1, 0xac, 0x42, 0xf6, 0x7e,
	0x18, 0xe0, 0xcc, 0x52, 0x8c, 0xf7, 0xe8, 0x72, 0x1a, 0x5c, 0x71, 0xff, 0x98, 0xea, 0xb0, 0xc3,
	0xe6, 0x02, 0x7c, 0x0e, 0xb5, 0xec, 0x94, 0xb8, 0x26, 0xfd, 0xe1, 0xee, 0x62, 0x85, 0x3a, 0x84,
	0x9e, 0x90, 0xa3, 0x39, 0xb3, 0xd5, 0x03, 0x98, 0x0b, 0xb1, 0x09, 0xd6, 0x17, 0x3e, 0x2d, 0x1a,
	0x21, 0x3b, 0xe2, 0x1e, 0xd4, 0x26, 0xc1, 0x65, 0xca, 0xa9, 0x92, 0x0e, 0xcb, 0x2f, 0xaf, 0xcc,
	0x9e, 0xe1, 0xfd, 0x32, 0xa0, 0x51, 0x2d, 0x28, 0x22, 0xd8, 0x7d, 0x39, 0xe6, 0x85, 0x3e, 0x9d,
	0xab, 0x1e, 0x9b, 0x8b, 0x1e, 0xbf, 0x2c, 0x3d, 0xb6, 0xc8, 0xe3, 0xf6, 0xca, 0x46, 0x59, 0xab,
	0xdb, 0x7f, 0x0c, 0xd8, 0xd6, 0x9b, 0xea, 0x86, 0x94, 0x3e, 0x81, 0x5d, 0x3f, 0xf1, 0xc5, 0x49,
	0x1a, 0xcb, 0x88, 0x07, 0xe2, 0x93, 0xc8, 0x5a, 0x2e, 0x33, 0xba, 0xc5, 0x96, 0x01, 0x74, 0x61,
	0xd3, 0x4f, 0x24, 0xe5, 0xc0, 0xa2, 0x1f, 0x97, 0x57, 0x7c, 0x51, 0x06, 0x6a, 0x53, 0xa0, 0x07,
	0x2b, 0xda, 0x7b, 0xad, 0x61, 0xfe, 0x34, 0x60, 0xa7, 0x32, 0x0b, 0xf8, 0x10, 0x1a, 0xef, 0x46,
	0xa3, 0x34, 0x0e, 0x46, 0x53, 0x16, 0x8c, 0xc3, 0x34, 0x29, 0x82, 0x5d, 0x90, 0x62, 0x0b, 0xb6,
	0x06, 0x81, 0x0a, 0x55, 0x3a, 0xce, 0xcd, 0x1a, 0x6c, 0x76, 0xcf, 0x72, 0x35, 0x90, 0xe2, 0x22,
	0x07, 0x2d, 0x02, 0xe7, 0x82, 0x0c, 0xfd, 0xc0, 0x55, 0x9c, 0xc7, 0x6f, 0xe7, 0x99, 0x9c, 0x09,
	0x32, 0xbb, 0x1f, 0xc3, 0x2b, 0xfe, 0x59, 0x0a, 0x4e, 0x33, 0xe8, 0xb0, 0xd9, 0xdd, 0xbb, 0x0f,
	0x75, 0x6d, 0x10, 0x57, 0xf5, 0x91, 0xf7, 0xdd, 0x84, 0xfd, 0x6b, 0x86, 0xee, 0x3f, 0x95, 0x10,
	0xc1, 0x56, 0xd3, 0x28, 0x8f, 0xcc, 0x61, 0x74, 0xc6, 0x37, 0x65, 0x59, 0x6b, 0x54, 0xd6, 0x47,
	0xff, 0xde, 0x0e, 0x6b, 0xad, 0xf0, 0x6f, 0xa3, 0x58, 0xe4, 0xda, 0xba, 0xb8, 0x21, 0x13, 0x5a,
	0x6c, 0x66, 0x35, 0xb6, 0x5e, 0x75, 0x0e, 0xbd, 0x6b, 0x76, 0xd3, 0x3a, 0x03, 0xe8, 0x0e, 0x8b,
	0x41, 0x3c, 0xe3, 0xf1, 0x24, 0x1c, 0x71, 0x7c, 0x9b, 0xf9, 0xae, 0xf2, 0x37, 0x07, 0x2b, 0xdb,
	0x51, 0x7b, 0xaa, 0x5a, 0xee, 0x32, 0x90, 0x3f, 0x4f, 0xde, 0xad, 0xf3, 0x0d, 0x82, 0x8e, 0xfe,
	0x06, 0x00, 0x00, 0xff, 0xff, 0x2d, 0xf9, 0x5f, 0x9b, 0xf7, 0x06, 0x00, 0x00,
}
